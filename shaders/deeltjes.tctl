#version 410 core
#define PI 3.1415926538


layout(vertices = 3) out;

in VS_TC_VERTEX
{
	in vec3 normal;
	in vec3 pos;
} tc_in[];

out TC_TS_VERTEX
{
	out vec3 normal;
	out vec3 pos;
	out vec2 tex;
} ts_in[];

uniform mat4 modelView;


/*	patch out float gl_TessLevelOuter[4];
	patch out float gl_TessLevelInner[2];*/


int tessLevelFunc(vec3 p)
{
	//return 1;
	const float afstand = 6.0, maxVal = 128.0;
	int tess = int( max(2.0, min(maxVal, ((afstand - length(modelView * vec4(p, 1)) ) / afstand) * maxVal)));

	return tess;
}

float longitudeF(vec2 normalXZ)
{
	vec2	angleVec	= normalize(normalXZ);
	
	
	return atan(angleVec.x, angleVec.y);

}

void main()
{
	ts_in[gl_InvocationID].normal 	= tc_in[gl_InvocationID].normal;
	ts_in[gl_InvocationID].pos 		= tc_in[gl_InvocationID].pos;

	float 	latitude 	= (tc_in[gl_InvocationID].normal.y + 1.0) * 0.5;
	
	vec3 	longitudes;

	for(int i=0; i<3; i++)
		longitudes[i] = longitudeF(tc_in[i].normal.xz);

	float longitude = longitudes[gl_InvocationID];

	//Are we straddling the far edge?
	if(distance(longitudes[0], longitudes[1]) > PI || distance(longitudes[1], longitudes[2]) > PI || distance(longitudes[2], longitudes[0]) > PI)
	{
		//Ok so a distance is larger than PI, how do we solve it? If l < 0 we add PI * 2
		if(longitude < 0)
			longitude +=  PI * 2;
	}
	
	ts_in[gl_InvocationID].tex 	 = vec2(longitude / PI, latitude);


	if(gl_InvocationID == 0)
	{
		vec3 central = normalize(tc_in[0].pos + tc_in[1].pos + tc_in[2].pos);


		gl_TessLevelInner[0] = tessLevelFunc(central);

		int tess0 = tessLevelFunc(tc_in[0].pos);
		int tess1 = tessLevelFunc(tc_in[1].pos);
		int tess2 = tessLevelFunc(tc_in[2].pos);
		
		gl_TessLevelOuter[0] = max(tess0, tess1);
		gl_TessLevelOuter[1] = max(tess1, tess2);
		gl_TessLevelOuter[2] = max(tess2, tess0);
	}
} 