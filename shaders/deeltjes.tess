#version 410 core

layout(triangles, equal_spacing, ccw) in;

uniform mat4 modelView;
uniform mat4 projectie;

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2)
{
    return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
} 

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2)
{
    return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
}

in vec3 normal[];


in VS_TS_VERTEX
{
	in vec3 normal;
	in vec3 pos;
	in vec2 tex;
} ts_in[];


out TS_FS_VERTEX
{
	out vec3 normal;
	out vec3 kleur;
	out vec2 tex;
	out vec3 hexIndex;
} fs_in;

uniform sampler2D marsHoogte;

/*	patch in float gl_TessLevelOuter[4];
	patch in float gl_TessLevelInner[2];*/

void main()
{
    // Interpolate the attributes of the output vertex using the barycentric coordinates
    fs_in.normal = normalize(interpolate3D(ts_in[0].normal, ts_in[1].normal, ts_in[2].normal));
    
	fs_in.kleur	 = vec3(0.9, 0.4, 0.01);
	fs_in.tex	 = interpolate2D(ts_in[0].tex, ts_in[1].tex, ts_in[2].tex);

	fs_in.hexIndex = interpolate3D(vec3(1,0,0), vec3(0,1,0), vec3(0,0,1));

	
	float hoogte = 1.0 + (0.05 * texture(marsHoogte, fs_in.tex).r);

	gl_Position = 
		projectie * 
		modelView *
		vec4(
			hoogte * normalize(
				interpolate3D(ts_in[0].pos, ts_in[1].pos, ts_in[2].pos)
			), 
			1.0
		);
} 