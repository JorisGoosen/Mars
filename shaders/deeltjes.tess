#version 410 core

layout(triangles, equal_spacing, ccw) in;

uniform mat4 modelView;
uniform mat4 projectie;

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2)
{
    return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
} 

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2)
{
    return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
}

in vec3 normal[];


in VS_TS_VERTEX
{
	in vec3 normal;
	in vec3 pos;
	in vec2 tex;
} ts_in[];


out TS_FS_VERTEX
{
	out vec3 normal;
	out vec3 kleur;
	out vec2 tex;
} fs_in;

uniform sampler2D marsHoogte;

float hoogteDaar(vec2 tex)
{
	return 1.0 + (0.05 * texture(marsHoogte, tex).r);
}/*

mat4 rotationMatrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

vec3 normaalGradient(vec2 tex, float breedte)
{
	float 	omXas = hoogteDaar(tex - vec2(breedte, 	0)) 		- hoogteDaar(tex + vec2(breedte, 	0)),
			omZas = hoogteDaar(tex - vec2(0, 		breedte)) 	- hoogteDaar(tex + vec2(0, 			breedte));

	return (rotationMatrix(vec3(1,0,0), omXas * 10) * rotationMatrix(vec3(0,0,1), omZas * 10) * vec4(fs_in.normal, 0)).xyz;
}

*/
void main()
{
    // Interpolate the attributes of the output vertex using the barycentric coordinates
    fs_in.normal = normalize(interpolate3D(ts_in[0].normal, ts_in[1].normal, ts_in[2].normal));
   // fs_in.normal = normaalGradient(fs_in.tex, 0.01);

	fs_in.kleur	 = vec3(0.9, 0.4, 0.01);
	fs_in.tex	 = interpolate2D(ts_in[0].tex, ts_in[1].tex, ts_in[2].tex);

	
	gl_Position = 
		projectie * 
		modelView *
		vec4(
			hoogteDaar(fs_in.tex) * normalize(
				interpolate3D(ts_in[0].pos, ts_in[1].pos, ts_in[2].pos)
			), 
			1.0
		);
} 