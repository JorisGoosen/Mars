#version 440

layout(local_size_x = 16) in;
#define ID gl_GlobalInvocationID.x

#include "planeetDefinities.glsl"



// We hebben net in waterStroming.comp naar vakken1 geschreven, dus de nieuwe stromingswaardes staan daar.
// Maar we willen alsnog de nieuwe waterHoogte etc naar vakken1 schrijven, dus opletten.
void main()
{
	vec3 	n 			= vakMetas[ID].normaal.xyz;
	uint 	burenAantal = vakMetas[ID].burenAantal;
	float 	stroming 	= 0.0f,
			buurVocht	= 0.0f,
			mijnVocht	= vakken0[ID].vocht,
			buurLeven	= 0.0f,
			droesem 	= 0.0f,
			droesemWeg	= 0.0f;
	vec2 	snelheid 	= vec2(0.0f);
	vec3	hier		= vakHoogteNormaal(ID, false);

	//Ga de buur er telkens bijzoeken zodat we normalen kunnen berekenen en zo veel meer
	for(uint buur=0; buur < burenAantal && buur < 6; buur++)
	{	
		const uint 	buurID 		= vakMetas[ID].buren[buur],
					buurBuren 	= vakMetas[buurID].burenAantal;

		for(uint buurBuur=0; buurBuur < buurBuren; buurBuur++)
			if(vakMetas[buurID].buren[buurBuur] == ID)
			{
				
				float stroomWeg = vakken1[buurID].pijpen[buurBuur] 	- vakken1[ID].pijpen[buur];

				stroming  += stroomWeg;
				buurVocht += (vakken1[buurID].vocht - mijnVocht) / 6;
				buurLeven += vakken1[buurID].leven;
				snelheid  += vakMetas[ID].buurRicht[buur] * stroomWeg;

				//Als stroomWeg positief is gaat het dus richting de buren
				//Zou je denken? omdat stroming + waterHoogte nieuwe is voor mij is het logischer dat:
				// stroomWeg positief = droesem van buur komt bij mij 
				uint 	id 	= stroomWeg >= 0 ? buurID : ID;//,
						//weg	= stroomWeg <  0 ? buurID : ID;
				if(abs(stroomWeg) > 0 && vakken0[id].waterHoogte > 0 && abs(stroomWeg) < vakken0[id].waterHoogte)
					droesem		+=  sign(stroomWeg) * min(1, abs(stroomWeg / vakken0[id].waterHoogte)) * vakken0[id].droesem;

			//	droesem 	+= vakken0[id ].waterHoogte > stroomWeg ? ( stroomWeg / vakken0[id ].waterHoogte) * vakken0[id ].droesem : vakken0[id ].droesem;
			//	droesemWeg	+= vakken0[weg].waterHoogte > stroomWeg ? ( stroomWeg / vakken0[weg].waterHoogte) * vakken0[weg].droesem : vakken0[weg].droesem;
				break;
			}
	}

	//Dan tijd om het een ent ander weg te schrijven
	snelheid /= burenAantal;
	vakken1[ID].snelheid 	= snelheid;/// length(snelheid / burenAantal; //mix(vakken0[ID].snelheid, (snelheid / burenAantal), 1.0);
	vakken1[ID].waterHoogte = max(0, (vakken0[ID].waterHoogte + (stroming / PIJP_LENGTE)) - verdamping);
	vakken1[ID].vocht		= min(1.0, max(0.0, mijnVocht + buurVocht + min(verdamping, vakken0[ID].waterHoogte)));

	float 	leven = vakken0[ID].leven,
			regen = dot(regenPlek, n);

	//het lekker laten regenen
	if( regen > 0.96)
	{
		const float minderVocht = 0.03333;
		vakken1[ID].waterHoogte += vakken1[ID].vocht * minderVocht;
		vakken1[ID].vocht		*= 1.0 - minderVocht;
	}
	else if(regen < -0.99)
		leven = max(0.00001, leven);

	//droesem -= droesemWeg;

	//const float vertraging = 0.01;

	//droesem 	*= vertraging;//
	//droesemWeg 	*= PIJP_LENGTE;

	//laten we kijken of er iets veranderd moet worden aan de droesem
	float 	helling = max(0.2, (1.0f - dot(n, berekenNormaal(ID, true))));
			//helling	= sin(acos(helling));
	float	droesemCapaciteit 	= vakken0[ID].waterHoogte * DROESEMHEID * min(1.0, length(snelheid) * VERTRAGER),//max(0.0, vakken0[ID].waterHoogte * (DROESEMHEID * helling)),// * min(1.0, length(snelheid) * VERTRAGER))), 
			droesemAangespoeld 	= droesem + vakken0[ID].droesem;//* min(1.0, vakken0[ID].waterSchijn * WATERMULT); // * vakken0[ID].waterHoogte,
	
	//droesem = droesemCapaciteit - droesemAangespoeld;

				//   C > st
	//droesem *= droesem > 0 ? OPLOSHEID : BEZINKHEID;

	
	//droesem = sign(droesem) * max(0.0, min(1.0, abs(droesem)));

	//droesem *= ;

	//const float minHoogte = 0.001;
	//if(vakken0[ID].grondHoogte - droesem < minHoogte) 
	//	droesem = vakken0[ID].grondHoogte - minHoogte;

	//vakken1[ID].grondHoogte	= /*max(minHoogte,*/ vakken0[ID].grondHoogte 	- (droesem * WATERMULT) ; //);
	//vakken1[ID].droesem	 	=					 droesemAangespoeld			+ droesem ;

	//vakken1[ID].droesem	 =	 droesemAangespoeld;

	vakken1[ID].grondHoogte = vakken0[ID].grondHoogte;

	if(vakken1[ID].waterHoogte <= 0.00001)
		droesemAangespoeld = 0;

	if(isnan(droesemCapaciteit) || isinf(droesemCapaciteit))
		droesemCapaciteit = 0;

	droesem  = droesemAangespoeld - droesemCapaciteit;
	droesem	*= BEZINKHEID;

	if(isnan(droesem) || isinf(droesem))
		droesem = droesemAangespoeld;

	//if(vakken1[ID].waterHoogte <= 0.00001 && droesemAangespoeld > 0)
	if(droesem >= 0)
	{
		vakken1[ID].droesem 	= droesemAangespoeld - droesem;
		vakken1[ID].grondHoogte	= vakken0[ID].grondHoogte + (droesem * WATERMULT);
	}
	else
	{
		vakken1[ID].droesem 	= droesemAangespoeld;
		vakken1[ID].grondHoogte	= vakken0[ID].grondHoogte;
	}
	
	//hoop doet leven
	buurLeven  /= burenAantal;
	

	if(vakken1[ID].waterHoogte <= 0.05)		leven = max(0.0, min(vakken1[ID].vocht, max(leven * 1.01, leven + (buurLeven * 0.03333))));
	else if(vakken1[ID].waterHoogte > 2.0)	leven *= 0.85;
	else									leven *= 0.95;

	vakken1[ID].leven = leven;

	//if(vakken1[ID].waterHoogte <= 0.00001) vakken1[ID].droesem = 0;

}